import pandas as pd
import random
from collections import deque

# =========================
# CSV読み込み（すべて文字列）
# =========================
station = pd.read_csv("station.csv", dtype=str)
line = pd.read_csv("line.csv", dtype=str)
join = pd.read_csv("join.csv", dtype=str)
company = pd.read_csv("company.csv", dtype=str)

# =========================
# JR西日本
# =========================
JR_COMPANY_CD = "4"

jr_lines = set(line[line["company_cd"] == JR_COMPANY_CD]["line_cd"])
jr_joins = join[join["line_cd"].isin(jr_lines)]

# =========================
# station_cd → station_g_cd
# =========================
station_cd_to_g = dict(
    zip(station["station_cd"], station["station_g_cd"])
)

# station_g_cd → 駅名（代表）
station_g_to_name = (
    station.groupby("station_g_cd")["station_name"]
    .first()
    .to_dict()
)

# =========================
# 隣接リスト作成（station_g_cd単位）
# =========================
adj = {}

for _, row in jr_joins.iterrows():
    cd1 = row["station_cd1"]
    cd2 = row["station_cd2"]

    if cd1 not in station_cd_to_g or cd2 not in station_cd_to_g:
        continue

    g1 = station_cd_to_g[cd1]
    g2 = station_cd_to_g[cd2]

    if g1 == g2:
        continue

    adj.setdefault(g1, set()).add(g2)
    adj.setdefault(g2, set()).add(g1)

# =========================
# BFS 最短経路
# =========================
def bfs_shortest_path(adj, start, goal):
    visited = set()
    queue = deque([[start]])

    while queue:
        path = queue.popleft()
        node = path[-1]

        if node == goal:
            return path

        if node in visited:
            continue

        visited.add(node)

        for nxt in adj.get(node, []):
            if nxt not in visited:
                queue.append(path + [nxt])

    return None

# =========================
# スタート駅（甲南山手）
# =========================
START_G_CD = "1160308"

# ゴールが見つかるまで引き直す
all_candidates = list(adj.keys())

path = None
end_g_cd = None

while path is None:
    end_g_cd = random.choice(all_candidates)
    if end_g_cd == START_G_CD:
        continue
    path = bfs_shortest_path(adj, START_G_CD, end_g_cd)

# =========================
# 結果表示
# =========================
print("最短経路：")
for g in path:
    print(station_g_to_name.get(g, g))

print("\nスタート:", station_g_to_name[START_G_CD], f"({START_G_CD})")
print("ゴール:", station_g_to_name[end_g_cd], f"({end_g_cd})")
