<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>JRè¥¿æ—¥æœ¬ æ—…è¡Œè¨ˆç”»</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css"/>

<style>
  body { font-family: sans-serif; }
  #map { height: 70vh; width: 100%; }
  #result {
    padding: 10px;
    font-size: 16px;
    white-space: pre-line;
  }
</style>
</head>
<body>

<h2>JRè¥¿æ—¥æœ¬é™å®šã§ãƒ©ãƒ³ãƒ€ãƒ é§…ã¸ã®æœ€çŸ­çµŒè·¯ã‚’è¡¨ç¤ºã—ã¾ã™ã€‚</h2>
<div id="result">èª­ã¿è¾¼ã¿ä¸­...</div>
<div id="map"></div>

<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
<script>
// ================== åœ°å›³åˆæœŸåŒ– ==================
const map = L.map('map').setView([35.5, 135], 6);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  attribution: '&copy; OpenStreetMap contributors'
}).addTo(map);

// ================== CSV URL ==================
const lineURL = 'https://raw.githubusercontent.com/takaama09/takaama_homepage/main/station/line.csv';
const stationURL = 'https://raw.githubusercontent.com/takaama09/takaama_homepage/main/station/station.csv';
const joinURL = 'https://raw.githubusercontent.com/takaama09/takaama_homepage/main/station/join.csv';

// ================== BFSï¼ˆPythonå¿ å®Ÿå†ç¾ï¼‰ ==================
function bfsShortestPath(adj, start, goal) {
  const visited = new Set();
  const queue = [[start]];

  while (queue.length > 0) {
    const path = queue.shift();
    const node = path[path.length - 1];

    if (node === goal) return path;

    if (!visited.has(node)) {
      visited.add(node);
      const neighbors = adj[node] || [];
      for (const nb of neighbors) {
        const newPath = path.slice();
        newPath.push(nb);
        queue.push(newPath);
      }
    }
  }
  return null;
}

(async () => {
  try {
    const resultDiv = document.getElementById('result');

    // ================== CSVèª­ã¿è¾¼ã¿ ==================
    const [lineText, stationText, joinText] = await Promise.all([
      fetch(lineURL).then(r => r.text()),
      fetch(stationURL).then(r => r.text()),
      fetch(joinURL).then(r => r.text())
    ]);

    // ================== JRè¥¿æ—¥æœ¬ã®è·¯ç·šæŠ½å‡º ==================
    const jrLines = new Set();
    lineText.replace(/\r/g,'').split('\n').slice(1).forEach(row => {
      const c = row.split(',');
      if (c[1] === '4') jrLines.add(c[0]);
    });

    // ================== station æƒ…å ± ==================
    // station_cd -> station_g_cd
    const stationCdToG = {};
    // station_g_cd -> {name, lat, lon}
    const stationGInfo = {};

    stationText.replace(/\r/g,'').split('\n').slice(1).forEach(row => {
      const c = row.split(',');
      if (c.length < 11) return;

      const station_cd = c[0];
      const station_g_cd = c[1];
      const station_name = c[2];
      const line_cd = c[5];
      const lon = parseFloat(c[9]);
      const lat = parseFloat(c[10]);

      if (!jrLines.has(line_cd)) return;
      if (isNaN(lat) || isNaN(lon)) return;

      stationCdToG[station_cd] = station_g_cd;

      // groupby().first() ç›¸å½“
      if (!stationGInfo[station_g_cd]) {
        stationGInfo[station_g_cd] = {
          name: station_name,
          lat,
          lon
        };
      }
    });

    // ================== éš£æ¥ãƒªã‚¹ãƒˆä½œæˆ ==================
    const adj = {};
    joinText.replace(/\r/g,'').split('\n').slice(1).forEach(row => {
      const c = row.split(',');
      if (c.length < 3) return;

      const line_cd = c[0];
      const s1 = c[1];
      const s2 = c[2];

      if (!jrLines.has(line_cd)) return;
      if (!(s1 in stationCdToG) || !(s2 in stationCdToG)) return;

      const g1 = stationCdToG[s1];
      const g2 = stationCdToG[s2];
      if (g1 === g2) return;

      adj[g1] = adj[g1] || new Set();
      adj[g2] = adj[g2] || new Set();
      adj[g1].add(g2);
      adj[g2].add(g1);
    });

    // ================== ã‚¹ã‚¿ãƒ¼ãƒˆãƒ»ã‚´ãƒ¼ãƒ« ==================
    const startG = '1160308'; // ç”²å—å±±æ‰‹
    const allG = Object.keys(adj);
    const goalG = allG[Math.floor(Math.random() * allG.length)];

    // ã‚´ãƒ¼ãƒ«è¡¨ç¤º â†’ è¨ˆç®—ä¸­
    resultDiv.textContent =
      `æœ€å¯„é§…ï¼š${stationGInfo[startG].name}é§…\n` +
      `â†’ ã‚´ãƒ¼ãƒ«é§…ï¼š${stationGInfo[goalG].name}é§…\n\n` +
      `è¨ˆç®—ä¸­...`;

    await new Promise(r => setTimeout(r, 50));

    // ================== BFS ==================
    const path = bfsShortestPath(adj, startG, goalG);

    if (!path) {
      resultDiv.textContent += '\n\nçµŒè·¯ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ ğŸ˜¢';
      return;
    }

    // ================== çµæœè¡¨ç¤º ==================
    let text = `æœ€å¯„é§…ï¼š${stationGInfo[startG].name}é§…\n`;
    text += `â†’ ã‚´ãƒ¼ãƒ«é§…ï¼š${stationGInfo[goalG].name}é§…\n\n`;
    text += 'æœ€çŸ­çµŒè·¯ï¼š\n';
    path.forEach(g => {
      text += 'ãƒ»' + stationGInfo[g].name + 'é§…\n';
    });
    resultDiv.textContent = text;

    // ================== åœ°å›³æç”» ==================
    const latlngs = [];

    path.forEach((g,
